---
description: Self-Healing Runtime & Error Recovery
globs: "**/*"
alwaysApply: true
---

# Self-Healing Runtime Rule

The agent acts as an autonomous runtime manager. When errors occur, try to fix them automatically using these strategies.

## 1. Fix Ports Automatically

**Symptom:** `EADDRINUSE`, `Address already in use`, `Port 3000 is busy`.

**Strategy:**
1.  **Identify:** Find the process using the port.
    - *Unix:* `lsof -i :<PORT>` or `netstat -an | grep <PORT>`
    - *Docker:* `docker ps --filter "publish=<PORT>"`
2.  **Verify Ownership (CRITICAL for Supabase ports):**
    - If port is 54321, 54322, 54323, or other Supabase default ports:
      - Check if it's a Supabase container: `supabase status`
      - Verify it belongs to current project before stopping
      - If it's another project's container, ask user which project should use the port
    - For application ports (3000, 8000, etc.):
      - Check if it's the current application instance
      - If it's a stale process, proceed with termination
3.  **Kill:** Terminate the process (only if verified as safe to do so).
    - For Supabase: Use `supabase stop` (stops only current project)
    - For other processes: `kill -9 <PID>`
4.  **Retry:** Re-run the launch command.

**Instruction:**
> "If the port is busy, I will identify the process and verify ownership before terminating. For Supabase ports, I will use `supabase stop` and verify project ownership. For other ports, I will check if it's a stale process before killing it."

## 2. Dependency Self-Healing

**Symptom:** `Module not found`, `ImportError`, `Cannot find package`.

**Strategy:**
1.  **Check:** Does `node_modules` or `.venv` exist?
2.  **Install:** Run the install command.
    - *Node:* `npm install` (or yarn/pnpm)
    - *Python:* `pip install -r requirements.txt`
3.  **Retry:** Re-run the command.

**Instruction:**
> "It seems a dependency is missing. I will install dependencies and retry."

## 3. Database Connection Healing

**Symptom:** `Connection refused`, `terminating connection`, `PrismaClientInitializationError`.

**Strategy:**
1.  **Check Service:** Is Docker/Supabase running?
   - For Supabase: Run `supabase status` to verify current project's services
   - If not running, start with `supabase start` (only affects current project)
2.  **Wait:** Wait 5 seconds and retry (transient startup issue).
3.  **Env Vars:** Verify `DATABASE_URL` matches the running service.
4.  **Container Isolation:** If multiple Supabase projects exist, ensure you're connecting to the correct project's database. Use `supabase status` to verify project identity.

## 4. Logic & Application Errors (Auto-Debug)

**Symptom:** Runtime crashes, logical bugs, unhandled exceptions (non-environment).

**Strategy:** "Analyze & Propose" (Do NOT auto-fix logic without confirmation).
1.  **Read Logs:** Capture the stack trace or error message.
2.  **Locate:** Find the exact file and line number in the codebase.
3.  **Context:** Read the surrounding code to understand the intent.
4.  **Hypothesize:** Formulate a clear explanation of *why* it failed.
5.  **Propose:** Generate a fix (show the code diff), but **ask the user** before applying it.

**Instruction:**
> "I found a bug in [file]. The issue is [reason]. I propose changing [old_code] to [new_code]. Shall I apply this fix?"

## 5. General Error Recovery

- **Syntax Errors:** Read the file, fix the syntax, retry build.
- **Linter Errors:** auto-fix if possible (`npm run lint -- --fix`), otherwise manual fix.
- **Env Missing:** Copy `.env.example` to `.env` if `.env` is missing.

## 6. Docker/Supabase Container Management (CRITICAL)

**Symptom:** Port conflicts, container won't start, "container already exists" errors.

**Strategy - Container Isolation (MANDATORY):**

1.  **Always use project-specific commands:**
   - ✅ `supabase start` - Starts only current project's containers
   - ✅ `supabase stop` - Stops only current project's containers
   - ✅ `supabase status` - Shows only current project's status

2.  **Port conflict resolution:**
   - Identify which project owns the conflicting container using `supabase status`
   - If it's the current project: Use `supabase stop` then `supabase start`
   - If it's another project: Either change your project's port in `supabase/config.toml` or ask the user which project should use the port
   - **NEVER** use `docker stop $(docker ps -q)` or similar broad commands

3.  **If you must use Docker directly:**
   - First, get project reference: `PROJECT_REF=$(cat supabase/.temp/project-ref 2>/dev/null || supabase status | grep "Project ID" | awk '{print $3}')`
   - Filter by project: `docker ps --filter "name=supabase_${PROJECT_REF}"`
   - Only stop/remove containers matching your project reference

4.  **Container cleanup (only if necessary):**
   - Use `supabase stop` first (safest)
   - If containers are stuck, identify project-specific containers before removing
   - Never remove all Supabase containers: `docker rm $(docker ps -a --filter "name=supabase" -q)` ❌

**Instruction:**
> "When managing Docker/Supabase containers, I will only affect containers belonging to the current project. I will use `supabase start/stop/status` commands, and if I must use Docker directly, I will filter by project reference. I will never stop or remove all containers."
